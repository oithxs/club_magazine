# __僕だってシェル芸人になりたい__
__一般人はシェル芸人となれるのか__

_1年365日、昼夜を問わず人はターミナルに向かう。己は既に何でも知ってるように、もしくは己を試すように。そうするうちに人生の80％以上をターミナルの前で過ごす。そう、今もまさにそうなのだ。_  
_ならそれを極めた __シェル芸人__ になるのだって悪くないだろ？_


## __シェル芸とは__
> __シェル芸の定義バージョン1.1__
>
>マウスも使わず、ソースコードも残さず、GUIツールを立ち上げる間もなく、あらゆる調査・計算・テキスト処理をCLI端末へのコマンド入力一撃で終わらすこと。あるいはそのときのコマンド入力のこと。(上田ブログ - https://b.ueda.tech/?page=01434)  

つまりコマンドをつないで色んな処理（主にテキスト処理）をすることがシェル芸。それをする人がシェル芸人。  
「芸人」ってところが __かなり__ バカっぽいけど…コマンドへの知識、そのオプションの把握、華麗にパイプをつないで欲しい出力を一瞬で得てしまう姿は非常にカッコイイ（はず）。

僕もこれに憧れているけど、まだまだ修行中なので勉強していきたい。そういう記事  
「芸」とかちょっと…みたいな控えめな人も是非覚えてみてほしい。絶対に実生活で役に立つはず。僕がそうだからね。

今回シェルは `bash` を使うよ。ほかによく使われる `zsh` や `fish` はちょっと文法に違いがあるので気をつけて。 `zsh` はそんなに変わらないけどね。

それでは行ってみよう。

## __コマンド出力を別のコマンドへ渡す__
シェル芸をするならこれができないと厳しい。 `sed` だけでなんでもやるってパターンもあるけど…それは `sed` を極めた上位種のシェル芸人にしかできない。

- sedコマンドはチューリング完全 
    - (http://hfuji.hatenablog.jp/entry/2017/07/31/211018) 
- A proof that UNIX utility "sed" is Turing complete 
    - (http://www.catonmat.net/blog/proof-that-sed-is-turing-complete/)  

コマンドAの出力をコマンドBへ渡す方法はだいたい3つ。 __プロセス置換__ と __パイプ__ それと __リダイレクト__ だ。

普段の生活ではせいぜいパイプとリダイレクトを使うぐらい。例えば大量にものがあるディレクトリで `ls -al` を放つ時。

```sh
ls -al | less
```

としてログが一気に流れないようにするとか。他には同じように`ls -al`をファイルに書き出す時。

```sh
ls -al > huga.txt
```

みたいに書いたりする。実際これぐらいの使い方で全然困らないし、リダイレクトなんかできる時点でめっちゃ使える人だわ。

## __`||`と`&&`と`|&`__
### `||`
```sh
command1 || command2
```

command1が失敗したときにcommand2が実行される。

```sh
cd ~/ABC || mkdir ~/ABC
```

といったようにcdしたい先がない時、勝手に作ってくれるような書き方ができる。

### `&&`
```sh
command1 && command2
```

反対にcommand1が成功したときにcommand2が実行される。

```sh
ls 黒歴史 && rm ./*
```

といったように黒歴史があるディレクトリの中身を消せるような書き方ができる。

### `|&`
```sh
command1 |& command2
```

command1のstdoutとstderrをまとめてcommand2のstdinに渡せる。`2>&1`を使うよりスマートに見える。

```sh
# stderrを捨てる。何も表示されない。
$ ls a 2>/dev/null | cat

# stderrをstdoutにリダイレクトする。
$ ls a 2>&1 | cat
ls: cannot access 'a': No such file or directory

# |&で2>&1の代わりをする。stderrを/dev/nullに捨ててるけどcatには渡ってることが分かる。
$ ls a 2>/dev/null |& cat
ls: cannot access 'a': No such file or directory
```

ただしこれは`2>&1`にいつも置き換えられるわけじゃない。こっちはパイプだからstdoutとstderrを`/dev/null`に捨てたい時なんかは使えない  
代わりに`&>`ってやつがある。

```sh
command1 2>&1 > /dev/null
# ↑同じ意味↓
command1 &> /dev/null
```

`&>`のほうが2文字も少ないのでいいんじゃないですかね。

## __`>>`と`<<`と`<<<`__
### `>>`
```sh
command1 >> hoge.txt
```

command1のstdoutをhoge.txtに __追記__ する。書き足していきたいときはこうするがいい。

```sh
echo 'export FZF_DEFAULT_OPTS="--cycle --reverse -1 -0 --height=40% --ansi"' >> ~/.bashrc
```

僕は新しい環境の整備とかする時は上みたいに設定を`~/.bashrc`に書き込むときとか多用する。まあ`.bashrc`をGitHubとかで管理すればいいんだけどね？

### `<<`
```sh
command << EOF
...
...
...
EOF
```

command1のstdinに改行込みで任意の文字列を書き込める。終わるときは`<<`の横に書いた文字列を書くと終わる。この文字列は任意なので`A`とかでもいい。

```sh
cat << EOF >> hoge.txt
abc
edf
edf?
EOF
```

いい例が思いつかないけどコマンドやファイルに複数行の文字列を渡したいときに使える。

### `<<<`
```sh
command1 <<< string
```

たま～に使う。`<`とほぼ同じだけど。

```sh
echo "abc edf" | read x y
```

ということをしたいとき。

```sh
read x y <<< "abc edf"
```

に書き換えられる。いまざっと思い返してみたけど使ったことがない。

## __`$()`と`<()`__
プロセス置換の類。

### `$()` 
```sh
command2 $(command1)
# ``でもOK
command2 `command1`
```

command1の結果をcommand2の引数として使いたいときに使う。

```sh
gcc $(ls -t1 *.c |head -n1)
```

タイムスタンプが一番新しい`.c`ファイルを`gcc`に放り込むときとかに便利。どうせC演習とかで __↑キー!↑キー!エンター!__ とかしてたんだろ!? やめちまえ!!

```sh
cc $(ls -t1 *.c | head -n1) && ./a.out
```

演習とかでは最後に書いたコードを試したいのでこう書けば↑エンターってキーストロークでできる。

### `<()`
```sh
command1 <(command2)
```

`$()`をリダイレクトするようにした版みたいなやつ。`command2 | command1`と動きは同じ。パフォーマンスは違う。ちなみに何個でも書ける。

```sh
cat <(echo $PATH) <(ls -l)
```

この例はいったい何がしたいんだ…って感じだけどこういうこともできる。

ここまででチュートリアルが終わりだぞ。

## `cat`コマンド
これまでの説明でもよくでる`cat`コマンド。シンプルだしシェル芸を開始するときにワンライナーの先頭によくありがち。

シンプルな`cat`コマンドだけど、結構オプションがある  
例えば`-n`を付けると行数ともに出力してくれたり、`-E`を付けると改行位置を表示してくれたりする。

他のオプションは`man cat`で確かめてほしいけど、`-n`とか`-E`があるとシェル芸的にどんな嬉しいことがあるの？ という話。

2つのファイル`f1.txt`と`f2.txt`がそれぞれこんな感じとする。
```sh
$ cat f1.txt
abc
edf
cg
$ cat f2.txt
123
456
789
```
f1の1行目が`abc`という商品でf2の1行目がその値段だったとき…？ こうやって縦に表示されると見づらい。

こういうときは`join`と`cat -n`を使う。
```sh
$ join <(cat -n f1.txt) <(cat -n f2.txt) 
1 abc 123
2 edf 456
3 cg 789
```
行数をキーにjoinするので綺麗に並べることができた。やったねぇ。

でも実際こういうのをしたいなら`paste`コマンドでいい  

```sh
paste f1.txt f2.txt
```

## __続け__
実はここぐらいまでであなたは下級シェル芸人ぐらいにはなっています。というのもシェル芸って結局↑のことの組み合わせで解決場合が多いからです。

もちろん`sed`や`grep`,`awk`といった三種の神器や`xargs`,`eval`みたいなのが使えればさらに効率よく欲しい出力を得られるんですが、これ全部説明するのは量が多すぎるし1回の記事で書く気力もないので部誌が続くならまあ…書くんじゃないかな。
